// Copyright (2019-2022) Paul Scherrer Institute
// SPDX-License-Identifier: GPL-3.0-or-later

#include <cmath>
#include "Coord.h"
#include "JFJochException.h"

Coord::Coord() {
    x = 0.0; y = 0.0; z = 0.0;
}

Coord::Coord(const double in[3]) {
    x = in[0];
    y = in[1];
    z = in[2];
}

Coord::Coord(double in_x, double in_y, double in_z) {
    x = in_x;
    y = in_y;
    z = in_z;
}

Coord Coord::operator+(const Coord &in) const {
    return Coord(this->x+in.x, this->y+in.y, this->z+in.z);
}

Coord Coord::operator-(const Coord &in) const {
    return Coord(this->x-in.x, this->y-in.y, this->z-in.z);
}

Coord Coord::operator*(double in) const {
    return Coord(this->x*in, this->y*in, this->z*in);
}

Coord Coord::operator/(double in) const {
    return Coord(this->x/in, this->y/in, this->z/in);
};

Coord Coord::operator-() const {
    return Coord(- this->x, -this->y, -this->z);
}

Coord& Coord::operator+=(const Coord &in) {
    this->x += in.x;
    this->y += in.y;
    this->z += in.z;
    return *this;
}

Coord& Coord::operator-=(const Coord &in) {
    this->x -= in.x;
    this->y -= in.y;
    this->z -= in.z;
    return *this;
}

Coord& Coord::operator*=(double in) {
    this->x *= in;
    this->y *= in;
    this->z *= in;
    return *this;
}

Coord& Coord::operator/=(double in) {
    this->x /= in;
    this->y /= in;
    this->z /= in;
    return *this;
}

Coord Coord::operator%(const Coord &in) const {
    return Coord(this->y * in.z - this->z * in.y,
            this->z * in.x - this->x * in.z,
            this->x * in.y - this->y * in.x);
}; // Cross product

double Coord::operator*(const Coord &in) const {
    return this->x * in.x + this->y * in.y + this->z * in.z;
};

bool Coord::operator==(const Coord &other) const {
    if ((this->x == other.x) && (this->y == other.y) && (this->z == other.z))
        return true;
    else
        return false;
}

double Coord::Length() const {
    return sqrt(this->x*this->x + this->y*this->y + this->z*this->z);
}

Coord Coord::Normalize() const {
    double len = Length();
    return Coord(this->x/len, this->y/len, this->z/len);
}

Coord operator*(const double M[3][3], const Coord& in) {
    return Coord(M[0][0] * in.x + M[0][1] * in.y + M[0][2] * in.z,
                 M[1][0] * in.x + M[1][1] * in.y + M[1][2] * in.z,
                 M[2][0] * in.x + M[2][1] * in.y + M[2][2] * in.z);
}

Coord convert_spherical(double r, double theta, double phi) {
    return Coord(r * sin(theta) * cos(phi),
            r * sin(theta) * sin(phi),
            r * cos(theta));
}

Coord operator*(double in1, const Coord& in2) {
    return in2 * in1;
}

double determinant(const Coord &in1, const Coord &in2, const Coord &in3) {
    return (in1 % in2) * in3;
}

const double& Coord::operator[](int64_t val) const {
    switch (val) {
        case 0:
            return x;
        case 1:
            return y;
        case 2:
            return z;
        default:
            throw JFJochException(JFJochExceptionCategory::InputParameterInvalid,
                                  "Coord index must be in range 0-2");
    }
}

double& Coord::operator[](int64_t val) {
    switch (val) {
        case 0:
            return x;
        case 1:
            return y;
        case 2:
            return z;
        default:
            throw JFJochException(JFJochExceptionCategory::InputParameterInvalid,
                                  "Coord index must be in range 0-2");
    }
}

std::ostream &operator<<( std::ostream &output, const Coord &in ) {
    output << in.x << " " << in.y << " " << in.z;
    return output;
}


/*
 * a, b - reduced basis of lattice generated by b_2, b_1.
 */
void PairReduction(const Coord b1, const Coord b2, Coord &a, Coord &b) {
    // |b2| <= |b1|
    if (b2 * b2 > b1 * b1)
        PairReduction(b2, b1, a, b);
    else {
        double r = std::round((b1 * b2) / (b2 * b2));
        Coord b3 = b1 - r * b2;
        if ((b3 * b3) < (b2 * b2)) {
            PairReduction(b2, b3, a, b);
        }
        else {
            a = b2, b = b3;
        }
    }
}

/*
 * a, b, c - reduced basis of lattice generated by b_1, b_2, b_3.
 * By Mikolaj Leonarski, University of Warsaw
 */
void SemaevReduction(Coord b1, Coord b2, Coord b3, Coord &a, Coord &b, Coord &c) {
    // sorting
    if (b1 * b1 > b2 * b2)
        SemaevReduction(b2, b1, b3, a, b ,c);
    else if (b1 * b1 > b3 * b3)
        SemaevReduction(b3, b2, b1, a, b ,c);
    else if (b2 * b2 > b3 * b3)
        SemaevReduction(b1, b3, b2, a, b ,c);
    else {
        // pair reduction (step 1)
        PairReduction(b1, b2, a, b);
        b1 = a, b2 = b;
        // x_1,x_2 s.t. ... (step 2)
        // check calculations !!!
        double y_1, y_2;
        y_1 = -((b1 * b3) / (b1 * b1)
                - (b1 * b2) * (b2 * b3) / (b1 * b1 * b2 * b2))
              /
              (1 - (b1 * b2) * (b1 * b2) / (b1 * b1 * b2 * b2));
        y_2 = -((b2 * b3) / (b2 * b2)
                - (b1 * b2) * (b1 * b3) / (b2 * b2 * b1 * b1))
              /
              (1 - (b1 * b2) * (b1 * b2) / (b1 * b1 * b2 * b2));

        int y_1_floor = floor(y_1), y_2_floor = floor(y_2);

        Coord temp = b3 + y_2_floor * b2 + y_1_floor * b1;
        Coord temp2;
        for (int x_1 = y_1_floor; x_1 <= y_1_floor + 1; x_1++)
            for (int x_2 = y_2_floor; x_2 <= y_2_floor + 1; x_2++) {
                temp2 = b3 + x_2 * b2 + x_1 * b1;
                if (temp2 * temp2 < temp * temp) {
                    temp = temp2;
                }
            }
        // step 3
        if (temp * temp < b3 * b3) {
            b3 = temp;
            SemaevReduction(b1, b2, b3, a, b, c);
        } else {
            a = b1, b = b2, c = b3;
        }
    }
}

Coord::Coord(const JFJochProtoBuf::Vector &v) {
    x = v.x();
    y = v.y();
    z = v.z();
}

Coord::operator JFJochProtoBuf::Vector() const {
    JFJochProtoBuf::Vector v;
    v.set_x(x);
    v.set_y(y);
    v.set_z(z);
    return v;
}

Coord RodriguesRotation(const Coord &c, const Coord &in_k, double theta) {
    Coord k = in_k.Normalize();
    return c * cos(theta) + (k % c) * sin(theta) + k * (k * c) * (1-cos(theta));
}

double angle_deg(const Coord &c1, const Coord &c2) {
    double cos_ang = c1 * c2 / (c1.Length() * c2.Length());
    return acos(cos_ang) * (180.0 / M_PI);
}

